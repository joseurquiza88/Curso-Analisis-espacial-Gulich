# Carga de paquetes ####
library(sp)
library(spdep)
library(RColorBrewer)
library(mapview)
library(ggplot2)
library(spatstat)

# Carga de base de datos ####
datos_rinde <- st_read("soja_depurado.gpkg")
head(datos_rinde)
class(datos_rinde)

datos_MO <- read.table("MO_Córdoba.txt", header = T)
head(datos_MO)
class(datos_MO)

# Transformación a objeto espacial y visualización ####
datos_MO <- st_as_sf(datos_MO, coords = c("x", "y"), crs = 22174)
class(datos_MO)
mapview(datos_MO,
        zcol = "MO") + mapview(datos_rinde)

cols <- colorRampPalette(rev(brewer.pal(11, "Spectral")))
mapview(datos_MO,
        zcol = "MO",
        alpha = 0,
        col.regions = cols)
##########################################################
# esto es para indicde de moran global
# Definición de vecindarios ####
## Datos MO ####
vecindarios_MO <- dnearneigh(datos_MO$geometry, 0, 25000)
summary(vecindarios_MO)
vecindarios_MO[20]

plot(
  vecindarios_MO,
  datos_MO$geometry,
  col = "#009999",
  pch = 20,
  cex = 1
)
# LOS VECINDARIOS
lw_MO <- nb2listw(vecindarios_MO, style = "W")
lw_MO

# Opción para contemplar observaciones sin vecindario
spdep::set.ZeroPolicyOption(TRUE)

lw_MO <- nb2listw(vecindarios_MO, style = "W")
lw_MO$weights[20]

## Datos MO ponderando por distancia ####
vecindarios_MO_p <- dnearneigh(datos_MO$geometry, 0, 25000)
summary(vecindarios_MO_p)

plot(
  vecindarios_MO_p,
  datos_MO$geometry,
  col = "#009999",
  pch = 20,
  cex = 0.5
)

vecindarios_MO_p[20]

dist <- spdep::nbdists(vecindarios_MO_p, datos_MO)
dist[20]
fdist <- lapply(dist, function(x)
  (1 / (x / 100)))

lw_MO_p <-
  try(spdep::nb2listw(vecindarios_MO_p, glist = fdist, style = "W"),
      silent = TRUE)
lw_MO_p$weights[20]

## Datos Rendimiento ####
vecindarios_rinde <- dnearneigh(datos_rinde$geom, 0, 10)
summary(vecindarios_rinde)

plot(
  vecindarios_rinde,
  datos_rinde$geom,
  col = "#009999",
  pch = 20,
  cex = 0.5
)

lw_rinde <-
  nb2listw(vecindarios_rinde, style = "W", zero.policy = T)

### Cálculo del índice de autocorrelación espacial de Moran
# hace 1000 permutaciones, hace 
# no tiene en cuenta el valor espacial
#toma aleatoriamente valores, 1000 valores
plot(imoran_MO)
imoran_MO <-
  moran.mc(datos_MO$MO, lw_MO_p, nsim = 1000, zero.policy = T)
imoran_MO
# es como que calculo 1000 indices de moran 
# vemos si es significativa
#p-value = 0.000999 ESTADISTICAMENTE SIGNIFICATIVO

imoran_rinde <-
  moran.mc(datos_rinde$REND,
           lw_rinde,
           nsim = 1000,
           zero.policy = T)
imoran_rinde



#################################################
### Cálculo del IM para multiples distancias
distancias <- function (dmax) {
  vec <- dnearneigh(datos_MO, 0, dmax)
  lw <- nb2listw(vec, style = "W")
  i.moran <- moran.mc(datos_MO$MO, lw, nsim = 999, zero.policy =
                        T)
  tabla <- data.frame("Distancia" = dmax, "MI" = i.moran$statistic)
  tabla
}

tablad <-
  do.call(rbind, lapply(c(
    seq(15000, 40000, 1000), seq(45000, 80000, 5000)
  ), distancias))
tablad

p <- ggplot(tablad, aes(x = Distancia, y = MI)) +
  geom_point(size = 3, color = "black") +
  geom_line(size = 1, color = "blue") +
  scale_x_continuous(limits = c(15000, 80000),
                     breaks = seq(15000, 80000, 5000)) +
  ylab("Moran's I") +
  xlab("Distancia (m)") +
  theme_light()
p

# Esto nos va a servir para elegir la distancia
# vemos que el indice de moran sube pero a 24 km
# tiende a bajar. el valor seleccionado de 25 esta bien
# cuanto mayor sea el indice es mejor, es decir mas cercano a 1
#significa que hay autocorrelacion espacial
#####################################################
#######################################
# Patrones de Puntos ####
data(swedishpines)
summary(swedishpines)
plot(swedishpines)

data(bei)
summary(bei)
plot(bei)

data(urkiola)
summary(urkiola)
plot(urkiola)

datos <- bei
pendiente <- bei.extra$grad
plot(pendiente)

## Localización de puntos en el espacio ####
plot(datos,
     pch = 20,
     cols = "grey70",
     main = "Localización de Árboles en un Bosque Tropical")

## Conteo por cuadrante ####
cuadrantes <- quadratcount(datos, nx = 5, ny = 5)
cuadrantes
plot(cuadrantes, add = TRUE)

## Intesidad por cuadrante ####
densidad.Q <- intensity(cuadrantes)
densidad.Q

## Plot de intesidad por cuadrante ####
plot(intensity(cuadrantes, image = TRUE),
     main = NULL,
     las = 1)
plot(
  datos,
  pch = 20,
  cex = 0.6,
  col = rgb(0, 0, 0, .5),
  add = TRUE
)

## Test de Aleatoriedad Espacial Completa ####
test_cuadrantes <- quadrat.test(datos, nx = 5, ny = 5)
test_cuadrantes

plot(datos,
     pch = 20,
     cols = "grey70",
     main = NULL)
plot(test_cuadrantes, add = TRUE)

## Plot de intensidad basada en kernel ####
den <- density(datos)

plot(den, main = "Kernel Gaussiano")
plot(datos, add = TRUE)

den2 <- density(datos, kernel = "disc")
plot(den2, main = "Kernel Circular")
plot(datos, add = TRUE)

## Modelado de la intesidad ####
modelo1 <- ppm(datos ~ 1)
modelo1

modelo2 <- ppm(datos ~ x + y)
modelo2

## Compración de modelos ####
anova(modelo1, modelo2, test = "Chi")

## Intesidad Ajustada ####
fmap <- predict(modelo2)
plot(modelo2)

## Modelado de la intesidad usando covarariable ####
modelo3 <- ppm(datos ~ pendiente)
modelo3

plot(predict(modelo3))
anova(modelo1, modelo3, test = "Chi")
